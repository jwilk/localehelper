#!/usr/bin/perl

use strict;
use warnings;

use v5.10;

sub clean_environment($)
{
    my ($regex) = @_;
    my @keys_to_unset = grep { m/$regex/ } keys %ENV;
    delete @ENV{@keys_to_unset};
}

sub update_environment(%)
{
    my %env = @_;
    @ENV{keys(%env)} = values(%env);
}

sub normalize_encoding($)
{
    local ($_) = @_;
    if (my ($prefix, $encoding) = m/^([^.]+[.])([^.]+)$/) {
        $encoding =~ y/A-Z/a-z/;
        $encoding =~ s/[-_]//g;
        return "$prefix$encoding";
    }
    return $_;
}

my $locale_var_re = qr/^(?:LC_[A-Z]+|LANG(?:UAGE)?)/;

my %env = ();
while (scalar(@ARGV) > 0) {
    given ($ARGV[0]) {
        when (m/^($locale_var_re)=(.*)$/) {
            my ($category, $locale) = ($1, $2);
            $env{$category} = $locale;
            shift @ARGV;
        }
        when ('--') {
            shift @ARGV;
            last;
        }
        default {
            last;
        }
    }
}

clean_environment(qr/^$locale_var_re$/);

my %all_locales = map { normalize_encoding($_) => 1 } split(/\n/, `locale -a`);
my %locales_to_generate = ();
while (my ($category, $locale) = each %env) {
    my $nlocale = normalize_encoding($locale);
    next if $category eq 'LANGUAGE';
    if (not exists $all_locales{$nlocale}) {
        $locales_to_generate{$nlocale} = 1;
    }
}

if (%locales_to_generate) {
    my @locales_to_generate = sort keys %locales_to_generate;
    local $" = ', ';
    print STDERR "localehelper: error: generating locales is not implemented yet; the following locales are missing:\n";
    print STDERR "localehelper: info: the following locales are missing: @locales_to_generate\n";
    exit 1;
}

update_environment(%env);

exec @ARGV;

# vim:ts=4 sw=4 et
